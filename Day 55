 Microservices Architecture

Today's Focus: Distributed System Design
What I Learned: Building scalable applications with microservices. Learned:

Microservices vs Monolith

Service decomposition

Inter-service communication

API Gateway pattern

Service discovery

Circuit breaker pattern

Practice Example: Microservice Setup
// Auth Service (auth-service/index.js)
const express = require('express');
const jwt = require('jsonwebtoken');

const app = express();
app.use(express.json());

app.post('/api/auth/login', (req, res) => {
    const { email, password } = req.body;
    // Validate credentials
    const token = jwt.sign({ userId: 123 }, process.env.JWT_SECRET);
    res.json({ token });
});

app.listen(3001, () => console.log('Auth service running on 3001'));

// User Service (user-service/index.js)
const express = require('express');
const axios = require('axios');

const app = express();
app.use(express.json());

// Inter-service communication
app.get('/api/users/:id', async (req, res) => {
    const token = req.headers.authorization;
    
    // Verify token with auth service
    try {
        await axios.get('http://auth-service:3001/api/auth/verify', {
            headers: { Authorization: token }
        });
        
        // Get user data
        const user = { id: req.params.id, name: 'John Doe' };
        res.json(user);
    } catch (error) {
        res.status(401).json({ error: 'Unauthorized' });
    }
});

app.listen(3002, () => console.log('User service running on 3002'));

// API Gateway (gateway/index.js)
const express = require('express');
const { createProxyMiddleware } = require('http-proxy-middleware');

const app = express();

app.use('/api/auth', createProxyMiddleware({
    target: 'http://auth-service:3001',
    changeOrigin: true
}));

app.use('/api/users', createProxyMiddleware({
    target: 'http://user-service:3002',
    changeOrigin: true
}));

app.listen(3000, () => console.log('API Gateway running on 3000'));
